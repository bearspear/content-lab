/**
 * Feature Loader Service
 * Responsible for loading feature plugins based on configuration
 *
 * ðŸ¤– AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by: scripts/generate-routes.js
 * Generated from: apps/content-lab/src/feature.config.js
 * Plugins discovered via: Convention-based discovery (Phase 3)
 *
 * Changes made here will be overwritten on next build.
 * To modify, edit feature.config.js and run: npm run generate:routes
 *
 * Phase 3: Plugins are now auto-discovered from features/ directory
 * No manual registration needed - just create the plugin file!
 *
 * See docs/PLUGIN_DEVELOPMENT_GUIDE.md for workflow details
 */

import { Injectable } from '@angular/core';
import { PluginRegistryService } from './plugin-registry.service';
import { FeatureBuildConfig, FeatureConfig } from './feature-config.interface';
import featureConfig from '../../../../apps/content-lab/src/feature.config.js';
import { allPlugins } from '../../../../apps/content-lab/src/app/app.routes';

@Injectable({
  providedIn: 'root'
})
export class FeatureLoaderService {
  constructor(private pluginRegistry: PluginRegistryService) {}

  /**
   * Load all enabled features from configuration
   * This method should be called during app initialization
   */
  async loadFeatures(): Promise<void> {
    const enabledFeatures = Object.entries(featureConfig.features)
      .filter(([_, config]) => (config as FeatureConfig).enabled)
      .map(([featureId, _]) => featureId);

    console.log(`[FeatureLoader] Loading ${enabledFeatures.length} enabled features from configuration...`);
    console.log(`[FeatureLoader] Build: ${featureConfig.buildName} v${featureConfig.version}`);

    const results = {
      loaded: [] as string[],
      failed: [] as { id: string; error: string }[]
    };

    // Load each enabled feature
    for (const featureId of enabledFeatures) {
      try {
        await this.loadFeaturePlugin(featureId);
        results.loaded.push(featureId);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error(`[FeatureLoader] Failed to load feature: ${featureId}`, error);
        results.failed.push({ id: featureId, error: errorMsg });
      }
    }

    // Log summary
    console.log(`[FeatureLoader] Load complete:`);
    console.log(`  âœ“ Loaded: ${results.loaded.length} features`);
    if (results.failed.length > 0) {
      console.warn(`  âœ— Failed: ${results.failed.length} features`);
      results.failed.forEach(({ id, error }) => {
        console.warn(`    - ${id}: ${error}`);
      });
    }
  }

  /**
   * Load and register a feature plugin using the static plugin map from app.routes.ts
   * @param featureId The feature ID to load
   */
  private async loadFeaturePlugin(featureId: string): Promise<void> {
    console.log(`[FeatureLoader] ðŸ” DEBUG: Attempting to load feature: ${featureId}`);
    console.log(`[FeatureLoader] ðŸ” DEBUG: allPlugins object type: ${typeof allPlugins}`);
    console.log(`[FeatureLoader] ðŸ” DEBUG: allPlugins keys: ${Object.keys(allPlugins).join(', ')}`);

    const plugin = allPlugins[featureId];
    console.log(`[FeatureLoader] ðŸ” DEBUG: Plugin lookup result for '${featureId}': ${plugin ? 'FOUND' : 'NOT FOUND'}`);

    if (!plugin) {
      console.error(`[FeatureLoader] âŒ ERROR: Unknown feature ID: ${featureId}`);
      console.error(`[FeatureLoader] Available features: ${Object.keys(allPlugins).join(', ')}`);
      throw new Error(`Unknown feature ID: ${featureId}`);
    }

    console.log(`[FeatureLoader] ðŸ” DEBUG: Plugin metadata: ${JSON.stringify(plugin.metadata)}`);

    // Register the plugin
    await this.pluginRegistry.register(plugin);

    console.log(`[FeatureLoader] âœ“ Loaded: ${featureId}`);
  }

  /**
   * Get the current build configuration
   */
  getBuildConfig() {
    return featureConfig;
  }

  /**
   * Get list of enabled feature IDs
   */
  getEnabledFeatures(): string[] {
    return Object.entries(featureConfig.features)
      .filter(([_, config]) => (config as FeatureConfig).enabled)
      .map(([featureId, _]) => featureId);
  }

  /**
   * Check if a specific feature is enabled
   */
  isFeatureEnabled(featureId: string): boolean {
    return featureConfig.features[featureId]?.enabled ?? false;
  }

  /**
   * Get configuration for a specific feature
   */
  getFeatureConfig(featureId: string): Record<string, any> | undefined {
    return featureConfig.features[featureId]?.config;
  }
}
